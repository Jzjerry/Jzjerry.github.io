<!DOCTYPE html>


<html lang="zh">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Through the Gate of Silver Key
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon2.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="https://i.loli.net/2020/07/24/9ySBAdOiUrCNt1Z.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Through the Gate of Silver Key</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['If that&#39;s the whisper from your ghost', '君のゴーストはそう囁くならば', '如果你的Ghost正如此低语的话'],
        startDelay: 0,
        typeSpeed: 50,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article
  id="post-SmallUpdate2022"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/29/SmallUpdate2022/"
    >Small Update in 2022</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/08/29/SmallUpdate2022/" class="article-date">
  <time datetime="2022-08-29T03:40:04.000Z" itemprop="datePublished">2022-08-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="微更新-in-2022"><a href="#微更新-in-2022" class="headerlink" title="微更新 in 2022"></a>微更新 in 2022</h1><p>在鸽了将近一年之后，我甚至已经进入新学校开始研究生生活了。然而按照目前的情况，再鸽下去依然十分可能。不过本次还是带来了一个微小的博客更新。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本次更新的主要目的就是为了宣布博客可以使用新地址来访问！ヾ(°▽ﾟ)ノ<br>新域名为：<a href="jzjerryblog.top">jzjerryblog.top</a><br>现在博客可以通过jzjerryblog.top或者<a href="http://www.jzjerryblog.top" target="_blank" rel="noopener">www.jzjerryblog.top</a> 访问了。<br>域名是在namesilo上购买的，价格也比较便宜，一年大概十几块。不过刚搭好的时候因为有的dns上还没有解析信息或者存留着旧ip，可能访问起来需要多试几次。</p>
<h2 id="P-S"><a href="#P-S" class="headerlink" title="P.S."></a>P.S.</h2><p>来到了新学校还是很快乐的，但是还有一些预期没有得到满足，目前整个学校还是半工地状态，餐饮和生活都说不上方便，希望之后能看到改变吧。<br>不知不觉中本科四年也就这样过去了，让我们看看接下来会发生什么。<br>哦对了，为了适应之后的学习，之后的博客可能还会试着同时更新英文版本，也许在更远的将来还会加入日文版本，希望我能做到坚持下去吧。</p>
<h1 id="Small-Update-in-2022"><a href="#Small-Update-in-2022" class="headerlink" title="Small Update in 2022"></a>Small Update in 2022</h1><p>After putting my blog aside for almost a year, I’ve even entered a brand new university and started my postgraduate life. Sadly, I’m likely gonna keep this state and stop updating for some time. But this time, I did bring a small update for the blog.</p>
<h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><p>So, the true purpose of this update is to tell you guys that we got a new address for the blog!<br>New address: <a href="jzjerryblog.top">jzjerryblog.top</a><br>Now the blog can be accessed by jzjerryblog.top or <a href="http://www.jzjerryblog.top" target="_blank" rel="noopener">www.jzjerryblog.top</a> .<br>I bought this domain on namesilo. It’s pretty much a bargain, costing around 10 RMB/year. As the link was established recently, it might takes several tries to access because of some DNS related issues.</p>
<h2 id="P-S-1"><a href="#P-S-1" class="headerlink" title="P.S."></a>P.S.</h2><p>It’s awesome being in the new uni, although some of my expectations have not been met yet. The whole campus is still under construction, food and living here are not convenient enough so far, hope it gonna be improved later.<br>The 4 years’ undergraduate has passed, let’s see what will happen next.<br>BTW, as you have seen, I will try to update my blog in both Chinese and English, and maybe in Japenese as well in future, hope I could make it.<br><img src=https://safebooru.org/images/3948/76ec35a046861860c5b0a141d9b7b41c05da6dc4.jpg alt="Petra Gurin by ももこ" width=60% height=60% /></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Misc/" rel="tag">Misc</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Translation-of-FPGA-NN"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/29/Translation-of-FPGA-NN/"
    >Translation of FPGA Implementations of Neural Networks - Preface</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/09/29/Translation-of-FPGA-NN/" class="article-date">
  <time datetime="2021-09-29T05:41:17.000Z" itemprop="datePublished">2021-09-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86/">知识</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="《神经网络的FPGA实现》前言中文翻译"><a href="#《神经网络的FPGA实现》前言中文翻译" class="headerlink" title="《神经网络的FPGA实现》前言中文翻译"></a>《神经网络的FPGA实现》前言中文翻译</h1><blockquote>
<p>2021.09.29 粗译完成 by Jzjerry</p>
<p>脑补翻译+全程DeepL校对</p>
<p>完全是一时兴起的翻译，刚好在准备托福和申请套磁，刚好看上了这个方向的Lab，刚好准备写RP，刚好搜高引用文献搜到这本书。</p>
<p>吐槽点：</p>
<p>首先是工科特有超级长难句、从句套娃和高强度被动语态。不得不赞叹TOEFL写作评分标准的伟大，看到长达4行的从句很难绷得住，也许这就是学术写作吧。可以预见我将来写paper会成为我曾经讨厌的人。</p>
<p>其次是本以为自己对硬件方面的了解可以支撑起专业名词的翻译，但是没想到这个前言的机器学习和深度学习的名词浓度远高于FPGA和硬件本身。以我比乐事薯片里薯片还少的深度学习知识，想找到正确的名词翻译实在是困难，大多数专业名词都把原文放在了后面的括号里，如有错误请多包含。</p>
<p>最后是篇幅上，我完全没想到一个前言翻译过来长达2400+字，看来想要做这方面的学习长路漫漫啊。本来还打算翻译目录部分，但是最后还是懒了。</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上世纪80年代和90年代早期，神经元计算机(Neurocomputers)的设计和实现领域中有过很多重要的工作。然而，大部分这些努力被评定为失败的：硬件神经元计算机从没有被广泛投入使用过。缺少成功的原因很大程度上来源于一个事实，早期的工作几乎完全以开发基于ASIC技术的自制神经元计算机为目标的，但在这个特定的领域上，ASIC技术从没能够得到充分的发展或者足够的竞争力来达成大范围的采用。而在另一方面，上文提到的这个时期的门阵列(gate-arrays)对于真正的人工神经网络(ANN)来说，要么规模不够大，要么速度不够快。但现在的技术有了改进：FPGA的容量和性能现在达到的水平足以成为一个更现实的替代品。因此，基于FPGA设计神经元计算机相较过去来说是一个更可行的提议了。本书总结了一些以此为目标的工作，并由12篇从很多投稿中评审选出的论文组成。本书书面上分为三个部分：第1章到第4章解决一些基本的问题；第5章到第11章阐述了各种不同的实现；第12章中可以看到从一个大规模项目中学到的教训，并且在现在和未来的技术下重新审视了设计上的问题。</p>
<p><strong>第1章</strong>中复习了人工神经网络理论的基础知识，讨论了不同的神经网络硬件实现方法（ASIC技术和FPGA技术都会讨论，重心放在人工神经网络的特殊特性上），并且总结了一个关于性能评估的简短笔记作为结尾。特别的点在于神经网络中固有的并行性的利用和算术方程的适当实现方法，特别是S型生长方程(Sigmoid Function)的实现方法。对于S型生长方程，本章节包含了一项十分重要的贡献。</p>
<p>一系列特定的算数运算构成了神经网络运算的核心，而<strong>第2章</strong>解决了一个基本的问题：如何选择正确的数字精度格式来达到精度和实现（成本和性能）上的最优权衡。标准的单精度或者双精度浮点表示法最小化了量化误差，但需要大量的硬件资源。精度较低的定点数表示法可能需要较少的硬件资源，但增加了会使神经网络的学习无法发生的量化误差，特别是在应用于回归问题上时。第2章验证了这个问题，并汇报了一个最近的实验。在这个实验中，我们在FPGA上同时使用浮点数和定点数实现了一个多层感知器。</p>
<p>在所有形式的并行计算上都有一个基础的问题，就是如何最好地将应用映射到硬件上。由于FPGA上基础计算单元之间具有相对死板的互联结构，这个问题变得更加困难了。<strong>第3章</strong>和<strong>第4章</strong>考虑了这个问题，阐述了一种协调简单硬件拓扑结构与复杂神经网络结构的理论框架和实用框架。其基本理念是，使用一种通过简化的拓扑结构和原创的数据交换体系，来生成可以轻松映射到FPGA上的强大的神经网络结构，即现场可编程神经元阵列(FPNA, Field Programmable Neural Arrays)。第3章会给出这个理论框架的基本定义和结果。而第4章会展示FPNA是如何将强大的神经网络结构简单地映射到数字硬件上的。其应用和实现将主要在课堂上讲述。</p>
<p><strong>第5章</strong>呈现了一个用于实现反向传播算法的脉动阵列(systolic)架构。这是第一个将整个学习阶段的计算完全并行化的反向传播算法的实现。这个阵列已经在Annapolis的FPGA协处理器上被成功实现了，并且达到了十分可观的高达5 GOPS的性能。本章中提及的新设计是面向Virtex系列板卡的。本章描述了使用脉动阵列设计工具MMAlpha自动导出这些高性能架构的流程，十分便于完成系统定制(facilitates system-specification)。这个工具让我们可以轻松地使用很高层次的语言(Alpha)来定制系统，同时也让我们可以通过进行设计探索(perform design exploration)来获取性能与使用手动优化的VHDL代码相媲美的架构。</p>
<p>关联网络(Associative networks)拥有许多特性，其中包含了快速、计算效率高的最佳匹配和内在的容错性，这使它对很多应用来说十分理想。但是，由于其对存储空间和带宽的需求，大型网络模拟起来可能会很慢。<strong>第6章</strong>呈现了一个简单而有效的关联网络模型，然后分别讨论了这个模型在单个高端计算机工作站、计算机集群和FPGA硬件上的实现和它们的性能分析。</p>
<p><strong>第7章</strong>描述了在一种名为可重构的正交存储器多处理器(REOMP, Reconfigurable Orthogonal Memory Multiprocessor)的使用FPGA的可重构并行计算机架构之上，对人工神经网络的实现。这种架构把 $p^2$ 个存储器模块，用行连接模式与列连接模式，连接至 $p$ 个可重构处理器上。REOMP被认为是一种神经网络新认知机(neural network neocognitron)的替换模型。本章由一篇对REOMP的描述、一个关于将新认知机映射到替换模型(alternative neocognitron mapping)的研究案例和一个对从1到64个处理器构成的系统的性能分析组成。</p>
<p><strong>第8章</strong>呈现了一个基于新的频率自适应学习算法(FAL, Frequency Adaptive Learning)的Kohonen自组织特征映射网络(SOFM, Self-Organizing Feature Map)的高效结构。这个新算法高效地取代了常规SOFM中的邻近自适应函数。本章提到的SOFM模型架构在XESS公司提供的原型验证环境下，在Xilinx Virtex FPGA上进行了原型验证。这个原型验证环境是一个专为快速原型开发设计的，稳定的功能验证环境。本章还给出了这个模型架构对512x512的彩色图像进行量化的实验结果。</p>
<p><strong>第9章</strong>讨论了另一个在可重构硬件上对SOFM的实现方式。基于通用快速原型验证系统RAPTOR2000，一种针对SOFM的硬件加速器被开发了出来。在Xilinx Virtex-E FPGA上，RAPTOR2000可以模拟复杂度高达1500万的系统门的硬件实现。RAPTOR2000通过PCI总线和主机——一台个人电脑或者工作站连接。在RAPTOR2000上使用5个FPGA模组，即可以将SOFM的在典型应用场景下的速度提升至个人电脑对SOFM的最优软件实现速度的190倍。</p>
<p><strong>第10章</strong>呈现了几个基本多层感知器(MLP)的硬件实现和一个名为 eXtended多层感知器 (XMLP)的改进版本。这个扩展版本是一个有二维层和可配置连接通路的，类似于MLP的前馈网络。本章讨论了在FPGA原型验证板上开发和测试的硬件实现和使用了两个不同抽象层次：寄存器传输层（VHDL）和高层算法层（Handel-C）的系统定制，同时讨论了不同并行程度的开发。主要的测试场景是语音识别应用。</p>
<p><strong>第11章</strong>描述了对图像和视频压缩的非线性预测器的脉动阵列实现。该实现基于一种使用硬件友好的学习算法的多层感知器。研究结果显示，即便是在性能相对平庸的FPGA设备商，这个架构也能获得足以在视频处理中完成实时训练的速度，也可以完成更多在图像压缩处理中的典型应用。</p>
<p><strong>第12章</strong>，即最后一章回顾了REMAP项目，该项目构建了神经网络应用的设计、实现和大规模并行架构的使用。本章提供了一个对各种算法中的计算需求的概述，引出了使用常规处理器的阵列来高效执行这些算法的方法。本章描述了基于SIMD(单指令多数据)设计原则的架构，同时也展示了一些重要且有代表性的ANN算法的移植实现。该系统作为架构实验室，在FPGA上得以实现。本章讨论了架构的演变和全同步SIMD架构的可扩展性。本章还描述了REMAP-$\beta$的VLSI（超大规模集成电路）替代实现的设计原则，并以对现在更加强大的FPGA电路如何应用于相似的架构的讨论作为结尾。</p>
<p>作者：AMOS R. OMONDI &amp; JAGATH C. RAJAPAKSE</p>
<h2 id="原文参考"><a href="#原文参考" class="headerlink" title="原文参考"></a>原文参考</h2><p>During the 1980s and early 1990s there was significant work in the design and implementation of hardware neurocomputers. Nevertheless, most of these efforts may be judged to have been unsuccessful: at no time have have hardware neurocomputers been in wide use. This lack of success may be largely attributed to the fact that earlier work was almost entirely aimed at developing custom neurocomputers, based on ASIC technology, but for such niche areas this technology was never sufficiently developed or competitive enough to justify large-scale adoption. On the other hand, gate-arrays of the period mentioned were never large enough nor fast enough for serious artificial-neural network (ANN) applications. But technology has now improved: the capacity and performance of current FPGAs are such that they present a much more realistic alternative. Consequently neurocomputers based on FPGAs are now a much more practical proposition than they have been in the past. This book summarizes some work towards this goal and consists of 12 papers that were selected, after review, from a number of submissions. The book is nominally divided into three parts: Chapters 1 through 4 deal with foundational issues; Chapters 5 through 11 deal with a variety of implementations; and Chapter 12 looks at the lessons learned from a large-scale project and also reconsiders design issues in light of current and future technology.<br>Chapter 1 reviews the basics of artificial-neural-network theory, discusses various aspects of the hardware implementation of neural networks (in both ASIC and FPGA technologies, with a focus on special features of artificial neural networks), and concludes with a brief note on performance-evaluation.<br>Special points are the exploitation of the parallelism inherent in neural networks and the appropriate implementation of arithmetic functions, especially the sigmoid function. With respect to the sigmoid function, the chapter includes a significant contribution.<br>Certain sequences of arithmetic operations form the core of neural-network computations, and the second chapter deals with a foundational issue: how to determine the numerical precision format that allows an optimum tradeoff between precision and implementation (cost and performance). Standard single or double precision floating-point representations minimize quantization errors while requiring significant hardware resources. Less precise fixed-point representation may require less hardware resources but add quantization errors that may prevent learning from taking place, especially in regression problems. Chapter 2 examines this issue and reports on a recent experiment where we implemented a multi-layer perceptron on an FPGA using both fixed and floating point precision.</p>
<p>A basic problem in all forms of parallel computing is how best to map applications onto hardware. In the case of FPGAs the difficulty is aggravated by the relatively rigid interconnection structures of the basic computing cells. Chapters 3 and 4 consider this problem: an appropriate theoretical and practical framework to reconcile simple hardware topologies with complex neural architectures is discussed. The basic concept is that of <em>Field Programmable</em> neural Arrays (FPNA) that lead to powerful neural architectures that are easy to map onto FPGAs, by means of a simplified topology and an original data exchange scheme. Chapter 3 gives the basic definition and results of the theoretical framework. And Chapter 4 shows how FPNAs lead to powerful neural architectures that are easy to map onto digital hardware. applications and implementations are described, focusing on a class.</p>
<p>Chapter 5 presents a systolic architecture for the complete back propagation algorithm. This is the first such implementation of the back propagation algorithm which completely parallelizes the entire computation of learning phase. The array has been implemented on an Annapolis FPGA based coprocessor and it achieves very favorable performance with range of 5 GOPS. The proposed new design targets Virtex boards. A description is given of the process of automatically deriving these high performance architectures using the systolic array design tool MMAlpha, facilitates system-specification This makes it easy to specify the system in a very high level language (Alpha) and also allows perform design exploration to obtain architectures whose performance is comparable to that obtained using hand optimized VHDL code.</p>
<p>Associative networks have a number of properties, including a rapid, compute efficient best-match and intrinsic fault tolerance, that make them ideal for many applications. However, large networks can be slow to emulate because of their storage and bandwidth requirements. Chapter 6 presents a simple but effective model of association and then discusses a performance analysis of the implementation this model on a single high-end PC workstation, a PC cluster, and FPGA hardware.</p>
<p>Chapter 7 describes the implementation of an artificial neural network in a reconfigurable parallel computer architecture using FPGA’s, named Reconfigurable Orthogonal Memory Multiprocessor (REOMP), which uses <em>p</em>2 memory modules connected to <em>p</em> reconfigurable processors, in row access mode, and column access mode. REOMP is considered as an alternative model of the neural network neocognitron. The chapter consists of a description of the REOMP architecture, a the case study of alternative neocognitron mapping, and a performance performance analysis with systems systems consisting of 1 to 64 processors.</p>
<p>Chapter 8 presents an efficient architecture of Kohonen Self-Organizing Feature Map (SOFM) based on a new Frequency Adaptive Learning (FAL) algorithm which efficiently replaces the neighborhood adaptation function of the conventional SOFM. The proposed SOFM architecture is prototyped on Xilinx Virtex FPGA using the prototyping environment provided by XESS. A robust functional verification environment is developed for rapid prototype development. Various experimental results are given for the quantization of a 512 X 512 pixel color image.</p>
<p>Chapter 9 consists of another discussion of an implementation of SOFMs in reconfigurable hardware. Based on the universal rapid prototyping system, RAPTOR2000, a hardware accelerator for self-organizing feature maps has been developed. Using Xilinx Virtex-E FPGAs, RAPTOR2000 is capable of emulating hardware implementations with a complexity of more than 15 million system gates. RAPTOR2000 is linked to its host – a standard personal computer or workstation – via the PCI bus. A speed-up of up to 190 is achieved with five FPGA modules on the RAPTOR2000 system compared to a software implementation on a state of the art personal computer for typical applications of SOFMs.</p>
<p>Chapter 10 presents several hardware implementations of a standard Multi Layer Perceptron (MLP) and a modified version called eXtended Multi-Layer Perceptron (XMLP). This extended version is an MLP-like feed-forward network with two-dimensional layers and configurable connection pathways. The discussion includes a description of hardware implementations have been developed and tested on an FPGA prototyping board and includes systems specifications using two different abstraction levels: register transfer level (VHDL) and a higher algorithmic-like level (Handel-C) as well as the exploitation of varying degrees of parallelism. The main test bed application is speech recognition.</p>
<p>Chapter 11 describes the implementation of a systolic array for a non-linear predictor for image and video compression. The implementation is based on a multilayer perceptron with a hardware-friendly learning algorithm. It is shown that even with relatively modest FPGA devices, the architecture attains the speeds necessary for real-time training in video applications and enabling more typical applications to be added to the image compression processing.</p>
<p>The final chapter consists of a retrospective look at the REMAP project, which was the construction of design, implementation, and use of large-scale parallel architectures for neural-network applications. The chapter gives an overview of the computational requirements found in algorithms in general and motivates the use of regular processor arrays for the efficient execution of such algorithms. The architecture, following the SIMD principle (Single Instruction stream, Multiple Data streams), is described, as well as the mapping of some important and representative ANN algorithms. Implemented in FPGA, the system served as an architecture laboratory. Variations of the architecture are discussed, as well as scalability of fully synchronous SIMD architectures. The design principles of a VLSI-implemented successor of REMAP-<em>β</em> are described, and the paper concludes with a discussion of how the more powerful FPGA circuits of today could be used in a similar architecture.</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Deep-Learning/" rel="tag">Deep Learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/FPGA/" rel="tag">FPGA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Neural-Network/" rel="tag">Neural Network</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Step-into-ESP32"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/05/12/Step-into-ESP32/"
    >Step-into-ESP32</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/05/12/Step-into-ESP32/" class="article-date">
  <time datetime="2021-05-12T07:27:51.000Z" itemprop="datePublished">2021-05-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="冷门框架芯片会梦见优秀IDE吗-——-ESP32入门实录"><a href="#冷门框架芯片会梦见优秀IDE吗-——-ESP32入门实录" class="headerlink" title="冷门框架芯片会梦见优秀IDE吗 —— ESP32入门实录"></a>冷门框架芯片会梦见优秀IDE吗 —— ESP32入门实录</h1><p>最近很难提起兴致写博客，正好因为兴趣和各种缘故入手了基于ESP32这个芯片的<strong>Node MCU-32S</strong>模块，打算用来做个课程设计，顺便熟悉一下新的芯片。然而令人没想到的是，为了完成设计目标，从搭建开发环境开始，我就已经走上了一条不归路。</p>
<p>那么接下来，本博客将会以相对轻松的语气来讲述我在入门ESP32路上（现在依然在这个路上）的经历和感受。</p>
<p>P.S. 提前剧透一个结局，PlatformIO成为了我开发ESP32的最终选择，PlatformIO+VS Code的开发组合适用性和舒适度都很好，十分推荐。</p>
<h2 id="从阅读官方指南开始"><a href="#从阅读官方指南开始" class="headerlink" title="从阅读官方指南开始"></a>从阅读官方指南开始</h2><blockquote>
<p>2021.05.12更新</p>
</blockquote>
<p>ESP32的原生开发环境是乐鑫（Espressif）主推的基于<code>CMake</code>和<code>Python</code>脚本的ESP-IDF(Espressif IoT Development Framework) 环境。</p>
<p>跟随着<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/get-started/index.html" target="_blank" rel="noopener">官方ESP-IDF编程指南</a>的脚步，只需要将整个环境git clone下来，然后执行一下一键安装脚本，基本上来说不会出现太大问题。接下来就可以直接使用<code>idf.py</code>这个Python脚本进行包括配置芯片框架（类似于STM32CUBE和MSP的syscfg的配置外设生成宏和头文件的功能）、编译项目、烧录项目、打开串口监视器等功能了。</p>
<p>不难看出，基于Python的pyOCD和乐鑫附加的各种功能，一套完整的工具链最终成功地被乐鑫集成到了同一个Python脚本里，这确实是个很不错的设计。但是，官方提供的主要部分也就到此为止了，如果没有其他的第三方工具，整个过程都只能在纯命令台下完成。作为一个被完善的图形化IDE惯坏了的人，一边用文本编辑器写代码，另一边用纯命令台完成编译、烧录实在很难适应，也不够现代化。于是，我投身尝试官方文档里看起来很诱人的选择：VS Code+官方ESP-IDF插件。</p>
<h2 id="Something-Wrong？难以配置的谜语人官方插件"><a href="#Something-Wrong？难以配置的谜语人官方插件" class="headerlink" title="Something Wrong？难以配置的谜语人官方插件"></a>Something Wrong？难以配置的谜语人官方插件</h2><p>打开VS Code，随手一搜就能找到有着高下载量的官方插件<a href="https://marketplace.visualstudio.com/items?itemName=espressif.esp-idf-extension" target="_blank" rel="noopener">Espressif IDF</a>。VS Code有着丰富的各类语言插件，对于C/C++语言支持也十分令人舒适，无论是找引用还是查看函数信息等都很方便，而ESP-IDF作为基于CMake的开发环境，也比较适合用VS Code开发，两者的组合看起来值得一试。</p>
<p>插件装上后，马上便弹出内置页面选取ESP-IDF下载路径。既然前文中已经把整个ESP-IDF环境装过一遍了，那我何必另起炉灶再下一遍呢？于是我选择了已有的ESP-IDF路径，插件很快就把环境给连接上了。看起来似乎没什么大问题，但当我打开一个Hello World项目时，刚按下编译按键，整个插件便陷入了短暂的沉默，不久之后弹出一句”Something wrong during building”之类的提示。</p>
<p><img src="https://i.loli.net/2021/05/12/Smpf64xnTJMBlUu.jpg" alt="What is something?"></p>
<p>不得不说这个Something Wrong让我实在摸不到头脑，这样的提示可以说是开发者最讨厌的了。之后的一段时间，我依次逛了逛乐鑫的论坛、GitHub上插件的issue，并重新让插件自己安装了一次ESP-IDF环境，但还是无果而终。</p>
<p>在放弃这个开发环境前的最后一个想法是我电脑上的Python版本问题，网上部分资料中确实提到过要求Python 3.7以上才能正常使用插件，但介于我在自己的Python 3.6上已经写了不少东西，加上DDL的追杀，还是选择尝试另一个环境比较省时省力。</p>
<h2 id="Arduino-IDE——行，但又不太行"><a href="#Arduino-IDE——行，但又不太行" class="headerlink" title="Arduino IDE——行，但又不太行"></a>Arduino IDE——行，但又不太行</h2><blockquote>
<p>2021.08.27更新</p>
</blockquote>
<p>作为拥有微控制器领域最好的社区生态的<strong>Arduino框架</strong>和<strong>Arduino IDE</strong>自然早就有人做好了针对ESP的移植，只需要在IDE里找到ESP32的Library下载安装，剩下的就是简单直接的开发了。单凭Arduino框架的开发已经可以做到绝大部分的事情了，不用说对于ESP32的核心功能——WIFI，Arduino下也有了做好了移植的库。从装好ESP32的插件到写出一个HTTP+json解析的简单应用（Arduino的库里很容易找到），我只花了不到1个小时，可以说是十分方便了。</p>
<p>然而说完了优点，Arduino框架下死板的地方也逐渐浮现了出来。ESP32的引脚自由度十分高，几乎每个引脚都能承担ADC、I2C、SPI的功能，然而在使用Arduino框架时，这些外设基本是被绑死了，尤其是I2C和SPI这样的片间通信接口。这就让稍微复杂一点的、需要变动引脚的程序开发十分艰难。虽然我认为基于原生库之上建立的Arduino框架一定是可以和原生库一起使用开发的，但是没有找到太多这方面的资料，只好作罢。</p>
<h2 id="Platform-IO-ESP-IDF——我找到的最优解"><a href="#Platform-IO-ESP-IDF——我找到的最优解" class="headerlink" title="Platform IO + ESP-IDF——我找到的最优解"></a>Platform IO + ESP-IDF——我找到的最优解</h2><p>绕了一大圈发现，想要全面的开发ESP32，脱离了官方的ESP-IDF是很难做到的，但是官方的环境配置和插件已经让我浪费了不少时间。这时，我在<strong>Platform IO</strong>这个著名VS Code插件中，找到了对ESP-IDF框架的支持。和Arduino一样的简便，只需要下好框架，选好Target芯片和开发板，新建项目，直接就可以开始开发。</p>
<p>令人开心的是，装好框架之后，整个Cmake的环境也自动地配置完成了，没有其他复杂的步骤。同时，浏览Examples也可以在IDE里进行，刷新Cmake列表、调整编译文件、加入自己的头文件、引入开源库等等一系列功能都完善的集成在了这一个插件上。最终，我在Platform IO上完成了整个项目（课程设计）开发，让我重新认识了这个插件。</p>
<h2 id="Node-js固件——Node-MCU的特色开发方式"><a href="#Node-js固件——Node-MCU的特色开发方式" class="headerlink" title="Node.js固件——Node MCU的特色开发方式"></a>Node.js固件——Node MCU的特色开发方式</h2><p>值得一提的是，我所使用的开发板是名为<a href="https://www.nodemcu.com/index_cn.html" target="_blank" rel="noopener">NodeMCU</a>的系列，其特色在于可以刷上一种固件，采用Lua脚本，让芯片可以直接用类似Node.js的方式开发网络应用，和MicroPython很相像。听起来十分美好，但是整体来说还是一个比较试验性的东西。</p>
<p>首先，官方提供的原始版本固件会把所有的外设和功能全部打开，导致芯片比较烫。其次，固件确实是可以定制的，可以选取需要的外设和功能，不需要的直接关闭，但是整个定制过程是基于一个<a href="https://nodemcu-build.com" target="_blank" rel="noopener">网页</a>的，而定制好的固件也并不能直接下载，而是会通过邮件发送到你的邮箱了。还有一点是，NodeMCU的ESP8266版本框架非常完善，甚至继承了u8g2库（OLED图形库），但是ESP32版本框架还是BETA版，很多功能不够完善。</p>
<p>总的来说，如果使用ESP8266版的NodeMCU的话，这个开发方式还是可以尝试的，但和MicroPython或者Arduino一样，面对复杂一些的开发，还是原生框架更胜一筹。</p>
<blockquote>
<p>如果有下一期的话，可能会写一下FreeRTOS和原生HAL库的内容</p>
<p>By Jzjerry 2021.08.27</p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ESP32/" rel="tag">ESP32</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Embedded/" rel="tag">Embedded</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Platform-IO/" rel="tag">Platform IO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RTOS/" rel="tag">RTOS</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Bit-Count"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/06/Bit-Count/"
    >Bit Count算法学习笔记</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/06/Bit-Count/" class="article-date">
  <time datetime="2021-01-06T05:59:11.000Z" itemprop="datePublished">2021-01-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86/">知识</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Pop-Count-位计数算法学习笔记"><a href="#Pop-Count-位计数算法学习笔记" class="headerlink" title="Pop_Count 位计数算法学习笔记"></a>Pop_Count 位计数算法学习笔记</h1><p>所谓Pop_Count算法，即Bit Population Count算法，解决的都是同一个简洁明了的问题——统计一个多位二进制数中<strong>‘1’</strong>的个数。如此简单的问题，不需要动脑子就可以想到循环判断的$O(n)$算法，而作为可能被频繁调用的功能，$O(n)$显然远算不上这个问题的最优解。在本篇中，我们将涉及多个”神乎其技“的Bit Count(位计数)算法，感受位操作与位运算的强大与奇妙。方便起见，本文将在C++语言下描述算法。</p>
<h2 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h2><p>抛开效率上的需求，相信大部分人第一分钟都能想到一个最朴素的算法：<strong>逐位统计</strong>。利用位运算符，我们只需要写一个循环就可以实现Pop_Count了。对于一个32位的无符号整型，利用一个for循环解决问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rekt_popcnt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		count += n&amp;(<span class="number">0x01</span>);</span><br><span class="line">		n = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这个算法的局限性非常大。该算法的时间复杂度是固定的，对远小于$2^32$的数据其复杂度依旧如此。</p>
<p>为了改进这个地方，我们保持逐位统计的思想，只需要对循环结构稍加优化即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iterated_popcnt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;n;n&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">        count += n&amp;(<span class="number">0x01</span>);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<strong>n</strong>右移到一定次数后，<strong>n</strong>将会变为0，循环结束，这样就能根据输入数据的最大位数决定循环的次数了。</p>
<p>但是这样依然存在一个缺点，当只有<strong>n</strong>的较高位为1时，该算法还是会逐位地统计。例如对$2^31$这个数，该算法还是会迭代31次，但最后统计结果<strong>count</strong>却只有1。</p>
<h2 id="Sparse算法与Dense算法"><a href="#Sparse算法与Dense算法" class="headerlink" title="Sparse算法与Dense算法"></a>Sparse算法与Dense算法</h2><p><strong>Sparse</strong>即稀疏，<strong>Dense</strong>即密集，顾名思义，这两种算法都是针对特殊的输入情况进行了优化。目前我们只对输入数据<strong>n</strong>引入了按位与运算和右移运算。而接下来的算法中将会体现减法在<strong>Pop_Count</strong>中的妙用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sparse_popcnt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        n &amp;= (n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以数据<strong>42</strong>为例，我们从数学上来看一下这个算法的过程：<br>$$<br>42=00101010(bin)<br>$$</p>
<p>$$<br>41=00101001(bin)<br>$$</p>
<p>$$<br>42\space\mathit{AND}\space41=00101000(bin)=40<br>$$</p>
<p>经过一次<code>n&amp;=(n-1)</code>的过程，我们直接将最低位的一个<strong>1</strong>给消除了。循环进行该过程每次消掉一个<strong>1</strong>，就完成了<strong>Pop_Count</strong>。也就是说，该算法的复杂度为$O(m)$，其中<strong>m</strong>为输入数据中<strong>1</strong>的个数。这比前文的朴素算法又在效率上提高了一个档次。但这也代表着效率取决于其中<strong>1</strong>的个数，<strong>1</strong>越少，时间开销越短，故称为<strong>Sparse</strong>稀疏算法。</p>
<p>如果我们知道了输入数据中<strong>1</strong>的个数很多，那自然可以反其道而行之，先取反再用<strong>Sparse</strong>统计，最后从最大位数中减去统计结果即可，这就是<strong>Dense</strong>算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dense_popcnt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* CHAR_BIT is the number of bits in char. */</span></span><br><span class="line">    <span class="comment">/* In most cases it equals to 8,but some   */</span></span><br><span class="line">    <span class="comment">/* architectruers use more than 8 bits	   */</span></span><br><span class="line">    <span class="comment">/* reference:https://stackoverflow.com/questions/3200954/what-is-char-bit*/</span></span><br><span class="line">    <span class="keyword">int</span> count=CHAR_BIT*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    n^=(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        --count;</span><br><span class="line">        n&amp;=(n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过让<strong>n</strong>与一个全1二进制数异或来达到取反的效果，之后就是同样的统计方法，只是这次我们进行倒数。</p>
<p>然而稀疏和密集始终是一对特殊情况，更多的数据是分布在这两者之间的，这两个算法在大多数情况下并没有优劣之分。</p>
<h2 id="查表法"><a href="#查表法" class="headerlink" title="查表法"></a>查表法</h2><p>对于<strong>Pop_Count</strong>来说，对每个数据的答案永远是固定的。使用打表与查表的方式，虽然是以牺牲空间为代价换取效率，但在不同场合下找到正确的分治方法总能起到很好的效果，对于<strong>硬件</strong>（FPGA等）设计等可以并行运算的情况也可用。</p>
<p>在一般情况下，8位(一个字节)的查表法比较常用，对超过8位的数据，只要用0补齐到<strong>8*n</strong>位，再分别查表结果相加即可。</p>
<p>如果用比较死板的方式打表可以直接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BITS_COUNT_TABLE[<span class="number">256</span>] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>,</span><br><span class="line">    <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>,</span><br><span class="line">    <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但打表的代码实现方式可以十分优雅，具体可参照文末参考中的博客<em>KAIO2-2013</em><sup>[1]</sup>(可以说是本文资料的最大来源了)。</p>
<h2 id="并行算法"><a href="#并行算法" class="headerlink" title="并行算法"></a>并行算法</h2><p>并行加速可以说是<strong>Pop_Count</strong>快速算法目前的终极答案，对于硬件设计这也是非常优秀的设计方式，之后的算法中基本都是基于这个原理实现的。</p>
<p>考虑两位数据：</p>
<table>
<thead>
<tr>
<th align="center">X1</th>
<th align="center">X0</th>
<th align="center">Count</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">00</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">01</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">01</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">10</td>
</tr>
</tbody></table>
<p>我们的任务就是要找出从<strong>( [X1,X0] )</strong>到<strong>Count</strong>的映射。</p>
<p>如果你学过数字电路的话，这个真值表应该十分熟悉吧。如果不考虑<strong>X1</strong>和<strong>X0</strong>之间在同组数据当中的关系，这个映射关系实际就是全加器——<strong>X1(1bit)+X0(1bit)=Count(2bits)</strong>。但实际上，我们并不能直接就把它们拆开相加，而需要在运算上把它们先拆开再相加，设<strong>X</strong>为由它们组合而成的2位数据：</p>
<p><strong>Count = (X&amp;01)+((X&gt;&gt;1)&amp;01)</strong></p>
<p>如果分步来讲的话：</p>
<ol>
<li>取出<strong>X</strong>的低位</li>
<li>将<strong>X</strong>的高位右移至低位</li>
<li>取出<strong>X</strong>的低位</li>
<li>将两次取出的值相加</li>
</ol>
<p>在这个运算的推导过程中，我们需要用到<strong>掩码(Mask)</strong>这个概念来屏蔽和保留的低位数据。在上述2位数据的情况下，<strong>掩码</strong>为<strong>01</strong>。</p>
<p>把位数增加至4位来考虑，按上面的运算就不能一次得到结果了，这时我们要两两分组，<strong>掩码</strong>就变为了<strong>0101</strong>：</p>
<p>第一次迭代：</p>
<p>*<em>X(4bits) = {Count_H(2bits),Count_L(2bits)} = *</em></p>
<p><strong>(X&amp;0101)+((X&gt;&gt;1)&amp;0101)</strong></p>
<p>此时高2位的<strong>Count</strong>结果和低2位的<strong>Count</strong>结果分别的存储在了高2位和低2位，我们还需要将它们加在一起。这时我们分取2位数据用的<strong>掩码</strong>就变成了<strong>0011</strong>。</p>
<p>第二次迭代：</p>
<p><strong>Count(4bits) = (X&amp;0011)+((X&gt;&gt;2)&amp;0011)</strong></p>
<p>在两次迭代后，得到<strong>Pop_Count</strong>结果。</p>
<p>归纳可以得到，每次迭代的运算表达式为：<br>$$<br>X = X&amp;((2^N-1)/2^{2^n}) + (X&gt;&gt;2^n)&amp;((2^N-1)/2^{2^n})<br>$$<br>其中$ N $为总位数，$ n $为当前迭代次数，$ (2^N-1)/2^{2^n} $就是掩码的表达式。</p>
<p>到这里不难看出这是典型的分治算法，称为并行算法的原因正式因为它同时完成了多个位数的统计，其迭代次数很轻松就能得证为$ \log_2^N $。</p>
<p>既然是并行算法，我们不妨用HDL来描述一下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> parr_popcnt(Data,cnt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">parameter</span> n = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">input</span> [n-<span class="number">1</span>:<span class="number">0</span>] Data;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>]cnt;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]cnt2[<span class="number">16</span>];</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>]cnt4[<span class="number">8</span>];</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]cnt8[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>]cnt16[<span class="number">2</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">integer</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">always</span>@(Data)</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i=i+<span class="number">1</span>)</span><br><span class="line">			cnt2[i] = Data[<span class="number">2</span>*i] + Data[<span class="number">2</span>*i+<span class="number">1</span>];</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i=i+<span class="number">1</span>)</span><br><span class="line">			cnt4[i] = cnt2[<span class="number">2</span>*i] + cnt2[<span class="number">2</span>*i+<span class="number">1</span>];</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i=i+<span class="number">1</span>)</span><br><span class="line">			cnt8[i] = cnt4[<span class="number">2</span>*i] + cnt4[<span class="number">2</span>*i+<span class="number">1</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i=i+<span class="number">1</span>)</span><br><span class="line">			cnt16[i] = cnt8[<span class="number">2</span>*i] + cnt8[<span class="number">2</span>*i+<span class="number">1</span>];</span><br><span class="line">		</span><br><span class="line">		cnt = cnt16[<span class="number">0</span>]+cnt16[<span class="number">1</span>];</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h2 id="并行算法-1"><a href="#并行算法-1" class="headerlink" title="并行算法++"></a>并行算法++</h2><blockquote>
<p>to be continue  2021.1.6 ====》</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><sup>[1]</sup><a href="https://www.cnblogs.com/Martinium/articles/popcount.html" target="_blank" rel="noopener">popcount算法分析-KAIO2(2013.3.1)</a></li>
<li><a href="http://www.nminoru.jp/~nminoru/programming/bitcount.html" target="_blank" rel="noopener">ビットを数える・探すアルゴリズム(2012.9.1)</a></li>
<li><a href="http://0x80.pl/articles/sse-popcount.html" target="_blank" rel="noopener">SSSE3: fast popcount(2017.1.28)</a></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Matlab-Audio-FFT"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/12/Matlab-Audio-FFT/"
    >MATLAB - First Step in Audio Processing</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/11/12/Matlab-Audio-FFT/" class="article-date">
  <time datetime="2020-11-12T02:10:52.000Z" itemprop="datePublished">2020-11-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="MATLAB音频录制与时域频域显示"><a href="#MATLAB音频录制与时域频域显示" class="headerlink" title="MATLAB音频录制与时域频域显示"></a>MATLAB音频录制与时域频域显示</h1><p>MATLAB中有各种形式的数据输入函数，其强大而全面的数据读取功能让我们可以使用函数将视频数据、音频数据读取、存储到工作区内。对于视频和音频，进行数学操作和运算后的具体效果可以很直观地被感受到，例如将视频降采样、将音频通过滤波器等。</p>
<p>本篇博客中，我们将使用MATLAB实现电脑音频输入，音频的频谱分析与音频的滤波。</p>
<h2 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h2><h3 id="1-音频的录制与导入"><a href="#1-音频的录制与导入" class="headerlink" title="1.音频的录制与导入"></a>1.音频的录制与导入</h3><p>MATLAB对音频提供了两种对象——<code>audiorecorder</code>与<code>audioplayer</code>。</p>
<p><code>audiorecoder</code>可以以特定的采样率、时长、分辨率、声道数等录制音频。在初始化好这个对象之后，使用<code>record</code>和<code>recordblocking</code>函数均可以开始录制音频。</p>
<p><code>record</code>使用非阻滞模式——即调用后会在继续执行之后的代码的同时进行录音。而<code>recordblocking</code>使用阻滞模式，在调用后到录制完成前都不会向下继续运行代码。对于<code>record</code>函数，可以将<code>audiorecoder</code>对象作为参数使用<code>pause</code>和<code>stop</code>函数暂停和停止录音。</p>
<p>而在录音完成后，可以使用<code>play</code>函数和<code>playblocking</code>函数来播放<code>audiorecoder</code>对象，其播放模式和<code>record</code>与<code>recordblocking</code>同理。</p>
<p><code>audioplayer</code>基本参数和<code>audiorecoder</code>类似，但是并不具有录音的功能。</p>
<p>想要导入具体的音频数据到工作区，可以使用<code>getaudiodata</code>函数，数据将会以向量的形式存储在工作区，可以使用<code>plot</code>函数绘制出来。</p>
<h3 id="2-音频数据的处理"><a href="#2-音频数据的处理" class="headerlink" title="2.音频数据的处理"></a>2.音频数据的处理</h3><p>将音频数据导入到工作区后，处理的过程就和普通的数据别无二致了。可以使用<code>fft</code>函数进行快速傅里叶变化，查看频谱信息；可以使用函数运算，在时域和频域进行变换和运算；当然，也可以使用MATLAB内置的滤波器对象和滤波器函数<code>filter</code>，对数据进行滤波。</p>
<p>在这里我们选取了<code>fft</code>和<code>filter</code>进行实验，先将原始音频数据的时域和频域绘出，经过滤波器后，再将处理过后的音频数据在时域和频域绘出。</p>
<p>绘制频域图像的方法在MATLAB相关教材、DSP相关教材和MATLAB官方帮助的示例中都有详细的解释，这里就不多提了。</p>
<h3 id="3-FDA-Tool中的滤波器设计"><a href="#3-FDA-Tool中的滤波器设计" class="headerlink" title="3.FDA Tool中的滤波器设计"></a>3.FDA Tool中的滤波器设计</h3><p><em>Filter Design&amp;Analysis Tool</em> 是MATLAB提供的滤波器设计与分析工具，在这个工具中，我们可以选取各种类型的FIR滤波器与IIR滤波器进行设计，并输出滤波器参数或滤波器对象到工作区或保存为MATLAB函数。在本篇中我们主要尝试对录入或读入的音频信号进行处理，所以主要需要注意的是滤波器采样率的设定，该数值一定要和你创建的<code>audioplayer</code>或<code>audiorecoder</code>中的参数对应。</p>
<p>具体的设计方法非常的自动化，只要调整好各项参数，如：滤波器的截止频率、通频带、增益分贝数、滤波器阶数等即可。</p>
<p>如果在MATLAB内部操作的话，建议将设计好的滤波器导出为MATLAB的滤波器对象，而如果想要将滤波器运用在<strong>DSP</strong>、<strong>ARM</strong>器件（例如使用CMSIS内核的STM32与MSP432），或其他编程语言的环境，可以将滤波器的一些系数作为数组导出。</p>
<p>如果不使用FDA Tool的话，也可以使用MATLAB可以直接调用的滤波器设计函数如<code>fircls</code>,<code>firls</code>,<code>fir1</code>,<code>fir2</code>等函数实现滤波器。</p>
<h3 id="4-音频对象的建立与播放"><a href="#4-音频对象的建立与播放" class="headerlink" title="4.音频对象的建立与播放"></a>4.音频对象的建立与播放</h3><p>将数据变化为可播放的对象十分简单，只需要利用<code>audioplayer(data,Fs)</code>去建立一个音频对象，并使用<code>play</code>去播放即可。</p>
<p>其中<code>data</code>对应单纯的音频数据，<code>Fs</code>对应采样率。如果两者不对应的话，可能会出现快放或者慢放的效果，当然也可以利用这个来做一些特殊的的事情。</p>
<h2 id="程序流程"><a href="#程序流程" class="headerlink" title="程序流程"></a>程序流程</h2><p>在本篇的程序中，将按序执行以下几件事：</p>
<ol>
<li>以<code>44100</code>的采样率录制<code>5</code>秒的音频。</li>
<li>绘制录入音频数据的波形与其快速傅里叶变换得到的频谱波形</li>
<li>将音频数据经过一个滤波器对象的处理</li>
<li>绘制处理后的音频数据的波形与其频谱波形</li>
<li>播放处理后的音频</li>
<li>播放原始音频</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">recObj = audiorecorder;</span><br><span class="line"></span><br><span class="line">Fs =  <span class="number">44100</span>; 	<span class="comment">% sample rate</span></span><br><span class="line">seconds = <span class="number">5</span>;	<span class="comment">% total length of audio</span></span><br><span class="line">nBits = <span class="number">16</span> ; 	</span><br><span class="line">nChannels = <span class="number">2</span> ; </span><br><span class="line">ID = <span class="number">-1</span>; 		<span class="comment">% default audio input device </span></span><br><span class="line">recObj = audiorecorder(Fs,nBits,nChannels,ID);</span><br><span class="line"></span><br><span class="line">total_samples = seconds*Fs;</span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'Start speaking.'</span>)</span><br><span class="line">recordblocking(recObj,seconds);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">'End of Recording.'</span>);</span><br><span class="line"></span><br><span class="line">data = getaudiodata(recObj);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fftresult = fft(data);</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">linspace</span>(<span class="number">0</span>,Fs/<span class="number">2</span>,total_samples/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(f,<span class="built_in">abs</span>(fftresult(<span class="number">1</span>:total_samples/<span class="number">2</span>+<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">axis([<span class="number">0</span> <span class="number">5000</span> <span class="number">0</span> <span class="number">2000</span>])	<span class="comment">% axis of the plot should be tuned depending on data </span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Design your Filter Object Hd here </span></span><br><span class="line"></span><br><span class="line">FIR_data = filter(Hd,data);</span><br><span class="line"></span><br><span class="line">t = <span class="built_in">linspace</span>(<span class="number">0</span>,seconds,total_samples);</span><br><span class="line">t = [t',t'];</span><br><span class="line"></span><br><span class="line">k = <span class="number">1</span>:total_samples;</span><br><span class="line"></span><br><span class="line">new_audio =  audioplayer(FIR_data, Fs);</span><br><span class="line"></span><br><span class="line">fftresult_alter = <span class="built_in">abs</span>(fft(FIR_data));</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">plot</span>(FIR_data);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">plot</span>(f,fftresult_alter(<span class="number">1</span>:total_samples/<span class="number">2</span>+<span class="number">1</span>))</span><br><span class="line">axis([<span class="number">0</span> <span class="number">5000</span> <span class="number">0</span> <span class="number">2000</span>])	<span class="comment">% axis of the plot should be tuned depending on data </span></span><br><span class="line"></span><br><span class="line">playblocking(new_audio);</span><br><span class="line">play(recObj);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>图片待补充——2020.11.15 by Jzjerry</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ww2.mathworks.cn/help/matlab/audio-and-video.htm" target="_blank" rel="noopener">音频和视频 - MATLAB &amp; Simulink - Mathworks 中国</a></p>
<p><a href="https://ww2.mathworks.cn/help/matlab/ref/fft.html" target="_blank" rel="noopener">快速傅里叶变换 - MATLAB &amp; Simulink - Mathworks 中国</a></p>
<p><a href="https://ww2.mathworks.cn/help/signal/digital-and-analog-filters.html" target="_blank" rel="noopener">数字和模拟滤波器 - MATLAB &amp; Simulink - Mathworks 中国</a></p>
<p><a href="https://blog.csdn.net/zxylv/article/details/102751960" target="_blank" rel="noopener">基于Matlab dsp工具箱 的实时音频采集及频谱显示 - Panda_1875的博客 - CSDN</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MATLAB/" rel="tag">MATLAB</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-OpenCv-Intro2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/06/OpenCv-Intro2/"
    >OpenCV For Python Ep.2 HelloWorld</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/09/06/OpenCv-Intro2/" class="article-date">
  <time datetime="2020-09-06T10:16:14.000Z" itemprop="datePublished">2020-09-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Python-OpenCV-Ep-2-初步应用-基于内置模型"><a href="#Python-OpenCV-Ep-2-初步应用-基于内置模型" class="headerlink" title="Python OpenCV Ep.2 初步应用(基于内置模型)"></a>Python OpenCV Ep.2 初步应用(基于内置模型)</h1><p><a href="https://jzjerry.github.io/2020/08/03/OpenCV-Intro/">查看上一期</a></p>
<p>在配置好Python环境下的OpenCV之后，我们可以了解到OpenCV已经内置了不少很完善的计算机视觉算法和例程，而在OpenCV的<a href="https://github.com/opencv/opencv" target="_blank" rel="noopener">GitHub</a>上也有很多可用的模型。在本文中，我们将把其中的一些算法与基本例程投入到使用当中，完成一个比较基础的计算机视觉程序——人脸与人脸关键点检测。</p>
<h2 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1.前置知识"></a>1.前置知识</h2><p><strong>①cvtColor(色彩空间转换)</strong></p>
<p><strong>②Drawing Function(OpenCV绘制函数)</strong></p>
<p><strong>③Cascade Classifier(级联分类器)</strong></p>
<p><strong>④Haar Features &amp; LBF Features(Haar特征与LBF特征)</strong></p>
<p><strong>etc…</strong></p>
<p>这些知识将逐步在之后(<del>也许是很久之后</del>)的其他博客中补充。</p>
<h2 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2.准备工作"></a>2.准备工作</h2><p>① 读入一个视频、摄像头或是单张的图像自然是我们程序中的第一步。这一部分内容已经在上一期中做了十分详尽的介绍，在本文中就不再重复了。</p>
<p>② 之后，我们需要提前准备好两个在本次的程序中需要用到的模型，分别是：</p>
<ul>
<li><strong>haarcascade_frontalface_alt2</strong></li>
<li><strong>lbfmodel</strong></li>
</ul>
<p>第一个模型可以在<a href="https://github.com/opencv/opencv/tree/master/data/haarcascades" target="_blank" rel="noopener">OpenCV的Github</a>上找到。</p>
<p>第二个模型可以在<a href="https://github.com/kurnianggoro/GSOC2017/blob/master/data/lbfmodel.yaml" target="_blank" rel="noopener">Facemark API for OpenCV</a>中找到。</p>
<h2 id="3-程序代码"><a href="#3-程序代码" class="headerlink" title="3.程序代码"></a>3.程序代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> py</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># load models</span></span><br><span class="line">cascade = cv.CascadeClassifier(<span class="string">"haarcascade_frontalface_alt2.xml"</span>)</span><br><span class="line"><span class="comment"># use this one if you are cat</span></span><br><span class="line"><span class="comment"># cascade = cv.CascadeClassifier("haarcascade_frontalcatface_extended.xml")</span></span><br><span class="line">facemark = cv.face.createFacemarkLBF()</span><br><span class="line">facemark.loadModel(<span class="string">"lbfmodel.yaml"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    print(<span class="string">"Cannot open camera"</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Capture frame-by-frame</span></span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># if frame is read correctly ret is True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        print(<span class="string">"Can't receive frame (stream end?). Exiting ..."</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># flip the frame</span></span><br><span class="line">    frame = cv.flip(frame,<span class="number">1</span>,dst = <span class="literal">None</span>)</span><br><span class="line">    gray = cv.cvtColor( frame , cv.COLOR_BGR2GRAY )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># run landmark</span></span><br><span class="line">    faces = cascade.detectMultiScale( gray , minSize = (<span class="number">30</span>,<span class="number">30</span>) )</span><br><span class="line">    <span class="keyword">if</span> len(faces)!=<span class="number">0</span>:</span><br><span class="line">        ok , landmarks = facemark.fit( gray , faces )</span><br><span class="line">        <span class="keyword">if</span> ok:</span><br><span class="line">            <span class="comment"># show result in points</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(landmarks[<span class="number">0</span>][<span class="number">0</span>])):</span><br><span class="line">                cv.circle( frame , tuple(landmarks[<span class="number">0</span>][<span class="number">0</span>][i]) , <span class="number">2</span> , (<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>) , <span class="number">-1</span> )</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(faces)):</span><br><span class="line">                cv.rectangle( frame , (faces[j][<span class="number">0</span>],faces[j][<span class="number">1</span>]) , (faces[j][<span class="number">0</span>]+faces[j][<span class="number">2</span>],faces[j][<span class="number">1</span>]+faces[j][<span class="number">3</span>]) , (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>) , <span class="number">3</span> )</span><br><span class="line">    <span class="comment"># Interrupt on key</span></span><br><span class="line">    cv.imshow( <span class="string">"Display"</span> , frame )</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == ord(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># When everything done, release the capture</span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>在本程序中我们使用的是摄像头捕捉来完成实时的人脸识别与关键点标记，因此我们首先建立一个<code>VideoCapture()</code>。</p>
<p>之后，就是使用CV2库的<code>CascadeClassifier</code>来载入我们所下载的Haar特征分类器模型。</p>
<p>同样地，我们建立新的LBF Facemark，并使用<code>face.loadModel()</code>来载入LBF特征模型。</p>
<p>在初始化工作完成后，就可以开始逐帧显示摄像头捕获图像，并使用模型对图像进行识别。为了处理图像，我们必须使用<code>cvtColor()</code>将图像的颜色空间从默认的BGR空间转换到GRAY灰度空间。先运行建立好的<code>CascadeClassifier</code>，从返回的数据中分别可以提取出人脸识别矩形的信息。然后，我们在这个矩形的范围内运行建立的<code>Facemark</code>，在人脸框内找出关键点。</p>
<p>为了用圆形绘制函数画出关键点，我们必须用一个<code>tuple</code>变量作为圆心的坐标点，而这一坐标点的信息实际是在返回数据<code>landmarks[0][0][i]</code>内的，因此我们利用循环来遍历<code>landmarks[0][0]</code>。</p>
<p>对于人脸框的绘制，<code>CascadeClassifier</code>识别后返回的矩形数据是以左上角坐标<code>(x,y)</code>和宽度高度<code>(w,h)</code>四个数据的形式存储的。而矩形绘制函数要求提供的是左上角和右下角的坐标点位置，只需要做个加法转换一下就行了。</p>
<p>运行之后的效果如下：</p>
<p><img src="https://i.loli.net/2020/09/06/37Vst8JN2olMHph.jpg" alt="layout.jpg"></p>
<img src="https://i.loli.net/2020/09/06/ruXElvHgUxK1DPV.jpg" alt="layout2.jpg" style="zoom: 67%;" />

<p>模型很成功地识别了田所浩二先辈<del>证明了野兽先辈人类说</del>。</p>
<img src="https://i.loli.net/2020/09/06/NGVtq8IBmCfb2lQ.jpg" alt="layout4.jpg" style="zoom:50%;" />

<p>对于纸片人没有做出反映，说明其准确度还是很可观的。</p>
<img src="https://i.loli.net/2020/09/06/HpStUdOqRMA52LG.jpg" alt="layout3.jpg" style="zoom: 80%;" />

<p>但是！却把露露的头饰误认成为了人脸，毕竟是比较老旧的模型，误识别的情况还是会存在的。</p>
<p>我也尝试过按照关键点的设计手绘人脸，确实也被识别了。</p>
<p>不过作为OpenCV的初步运用，确实只需要比较低的学习成本，上手非常容易。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.opencv.org/master/db/d28/tutorial_cascade_classifier.html" target="_blank" rel="noopener">OpenCV: <strong>Object Detection (objdetect module)</strong></a></p>
<p><a href="https://zhuanlan.zhihu.com/p/35390012" target="_blank" rel="noopener">OpenCV实战：人脸关键点检测（FaceMark）—— Amusi</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Vision/" rel="tag">Computer Vision</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-OpenCV-Intro"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/08/03/OpenCV-Intro/"
    >OpenCV For Python Ep.1 Intro</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/08/03/OpenCV-Intro/" class="article-date">
  <time datetime="2020-08-03T07:31:54.000Z" itemprop="datePublished">2020-08-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Python-OpenCV-Ep-1-入门"><a href="#Python-OpenCV-Ep-1-入门" class="headerlink" title="Python OpenCV Ep.1 入门"></a>Python OpenCV Ep.1 入门</h1><p>OpenCV是一个十分强大的计算机视觉开源平台，其不仅拥有大量现成的算法，还支持包含Python、C++在内的多种语言。对于刚入门计算机视觉的人来说，Python+OpenCV的学习环境是十分友好的。</p>
<h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1.环境配置"></a>1.环境配置</h2><p>首先需要确认已经安装<code>numpy</code>库，该库为OpenCV的前置要求，安装方法可以与下文一样地使用<code>pip</code>。</p>
<p>我们可以使用<code>pip</code>直接安装OpenCV：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure>

<p>或者可以选择安装包含了额外模型的contri版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-contirb-python</span><br></pre></td></tr></table></figure>

<p>鉴于<code>pip</code>默认的下载源下载速度较慢，推荐使用pypi的清华镜像或豆瓣镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install &lt;package name&gt; -i https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure>

<p>再或者，可以直接去pypi下载对应的whl文件，再使用pip安装，但是速度可能与第一种差不多。</p>
<p>安装完成后，我们只需要在建立Python程序时加入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br></pre></td></tr></table></figure>

<p>即可，其他多样化地<code>import</code>方式可以自行决定。</p>
<h2 id="2-初步使用"><a href="#2-初步使用" class="headerlink" title="2.初步使用"></a>2.初步使用</h2><p>作为计算机视觉库，不难想到我们第一步要做的就是获取图像处理的对象：图片和视频。</p>
<h3 id="读入图像"><a href="#读入图像" class="headerlink" title="读入图像"></a>读入图像</h3><p>在读入图像时，我们常用到的函数有：<code>imread()</code>和<code>imshow()</code>。</p>
<p>我们写一个简单的程序来读入和显示一张图像：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">"&lt;Pic&gt;"</span>)		<span class="comment"># &lt;Pic&gt;为一个图像的路径</span></span><br><span class="line">cv2.imshow(<span class="string">"&lt;Window Name&gt;"</span>,img) <span class="comment"># &lt;Window Name&gt;为窗口名称</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>只要设置好图像路径和窗口名，在确保路径正确的情况下，运行程序之后就可以得到一个图像显示窗口。但是运行后窗口只是一闪而过，要让窗口持续显示，则可以使用<code>waitKey()</code>函数。这样窗口就可以持续显示，并在按下任意按键后退出。</p>
<h3 id="写入图像"><a href="#写入图像" class="headerlink" title="写入图像"></a>写入图像</h3><p>如果要保存一张图像，我们需要用到<code>imwrite()</code>函数。</p>
<p>以前文程序为例，我们可以简单的实现把一张<code>.png</code>图片保存为<code>.jpg</code>图片的操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">"&lt;Pic(png)&gt;"</span>)		<span class="comment"># &lt;Pic(png)&gt;为一个png图像的路径</span></span><br><span class="line">cv2.imshow(<span class="string">"&lt;Window Name&gt;"</span>,img) 	<span class="comment"># &lt;Window Name&gt;为窗口名称</span></span><br><span class="line">key = cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> key == ord(<span class="string">"s"</span>):</span><br><span class="line">	cv2.imwrite(<span class="string">"&lt;Pic(jpg)&gt;"</span>,img)	<span class="comment">#&lt;Pic(jpg)&gt;为保存对象图片的位置路径</span></span><br></pre></td></tr></table></figure>

<p>我们对按下的按键进行判断，如果按下了<code>s</code>键，就保存该图片到一个新的路径，例如<code>D:\\pic.jpg</code>。</p>
<p>运行之后，如果我们以按下<code>s</code>键来关闭窗口，就可以保存下图像了。强烈建议使用绝对路径来作为保存路径，以免将图片存到Python运行路径或其他路径下。（后文存储视频同理）</p>
<h3 id="读取摄像头图像"><a href="#读取摄像头图像" class="headerlink" title="读取摄像头图像"></a>读取摄像头图像</h3><p>为了获取摄像头图像，我们需要使用<code>VideoCapture()</code>函数来创建一个视频捕获对象。</p>
<p>显示摄像头的程序如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)		<span class="comment">#parameter is the number for your camera devices or 								#a video path.</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    print(<span class="string">"Cannot open camera"</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Capture frame-by-frame</span></span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># if frame is read correctly ret is True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        print(<span class="string">"Can't receive frame (stream end?). Exiting ..."</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># Add flip on the frame</span></span><br><span class="line">    frame = cv.flip(frame,<span class="number">1</span>,dst = <span class="literal">None</span>)</span><br><span class="line">    <span class="comment"># Display the resulting frame</span></span><br><span class="line">    cv.imshow(<span class="string">'frame'</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == ord(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># When everything done, release the capture</span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>我们将<code>cap</code>作为一个视频捕获对象，先用判断语句确定是否打开了视频或摄像头，再进入一个循环，以逐帧的方式来获取摄像头信息。我们仍然可以用<code>imshow()</code>函数来在窗口中显示获得的图像信息，在循环中同样也用了<code>waitKey()</code>函数来作为退出循环的条件。</p>
<p>比较特别的是在<code>imshow()</code>之前，我们做了比较简单图像处理工序——水平翻转。使用<code>flip()</code>函数，我们可以对图像进行各种类型的翻转，参数第二项的代号代表着不同的翻转方式，例如最典型的水平翻转为编号为<strong>1</strong>，垂直翻转编号为<strong>0</strong>。</p>
<p>对于<code>VideoCapture()</code>中的摄像设备编号，建议结合具体电脑的设备信息使用，如果有虚拟摄像头（例如Facerig)或其他设备的话，可能会使实际的摄像头的编号向后改变。</p>
<h3 id="存储视频"><a href="#存储视频" class="headerlink" title="存储视频"></a>存储视频</h3><p>存储视频时我们需要用到<code>VideoWriter_fourcc()</code>和<code>VideoWriter()</code>函数。</p>
<p>其中第一个函数用于创建编码格式，第二个函数用于创建视频的具体参数。</p>
<p>对于编码格式可以具体查阅<strong>FourCC</strong>相关的编码知识，具体编码与程序运行的平台有关，在Windows可以使用<strong>DIVX</strong>进行测试。</p>
<p>对于视频参数，其格式为<code>(视频文件名,编码格式对象，每秒帧数，视频尺寸)</code>。</p>
<p>从摄像头里获取影像，并存储为视频的程序如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># Define the codec and create VideoWriter object</span></span><br><span class="line">fourcc = cv.VideoWriter_fourcc(*<span class="string">'DIVX'</span>)</span><br><span class="line">out = cv.VideoWriter(<span class="string">'output.avi'</span>, fourcc, <span class="number">20.0</span>, (<span class="number">640</span>,  <span class="number">480</span>))</span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        print(<span class="string">"Can't receive frame (stream end?). Exiting ..."</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    frame = cv.flip(frame, <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># write the flipped frame</span></span><br><span class="line">    out.write(frame)</span><br><span class="line">    cv.imshow(<span class="string">'frame'</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == ord(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># Release everything if job is finished</span></span><br><span class="line">cap.release()</span><br><span class="line">out.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>这次我们使用了垂直翻转作为处理操作。在按下<code>q</code>键退出之后，就可以在路径内找到对应的视频文件了。</p>
<h2 id="3-参考与扩展"><a href="#3-参考与扩展" class="headerlink" title="3.参考与扩展"></a>3.参考与扩展</h2><p><a href="https://docs.opencv.org/master/d6/d00/tutorial_py_root.html" target="_blank" rel="noopener">OpenCV-Python Tutorial</a>：官方教程地址</p>
<p><a href="http://www.fourcc.org" target="_blank" rel="noopener">FourCC</a>：FourCC视频编码官方地址</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Vision/" rel="tag">Computer Vision</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-FAST-Translation"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/20/FAST-Translation/"
    >FAST角点检测方法(Wikipedia翻译)</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/07/20/FAST-Translation/" class="article-date">
  <time datetime="2020-07-20T08:21:55.000Z" itemprop="datePublished">2020-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86/">知识</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="加速分段特征点测试"><a href="#加速分段特征点测试" class="headerlink" title="加速分段特征点测试"></a>加速分段特征点测试</h1><blockquote>
<p>原文地址：<a href="https://en.wikipedia.org/wiki/Features_from_accelerated_segment_test" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Features_from_accelerated_segment_test</a></p>
<p>第一次尝试翻译，渣翻请谅解，欢迎提出改进意见</p>
</blockquote>
<p>加速分段特征点检测(FAST)是一种角点检测方法，在很多计算机视觉的课题当中，它可以用于提取特征点并追踪(track)和比对(map)物体。FAST角点检测最初由Edward Rosten和Tom Drummond开发，并于2006年正式发布。<sup>[<a href="#ref">1</a>]</sup>FAST角点检测的一大最有前途的优点在于它的计算效率。正如FAST的名字一样，它确实比许多众所周知的特征提取方法，诸如使用高斯差分(DoG)的SIFT检测、SUSAN检测和Harris检测，要更加快速(faster)。更加强大的是，如果结合机器学习技术，FAST可以在计算时间和资源上达到很高的性能(Superior Performance)。FAST角点检测的高速性能(high-speed performance)使得它非常适合应用在实时视频的处理上。</p>
<h2 id="分段测试检测"><a href="#分段测试检测" class="headerlink" title="分段测试检测"></a>分段测试检测</h2><p>FAST角点检测使用了一个16像素的圆(半径为3的Bresenham圆)来确定(classify)选中的点<strong>p</strong>是否确实是一个角点。圆上的每一个像素都以顺时针编号为1至16。如果圆上一组<strong>N</strong>个相邻的像素点的亮度(intensity)全部都比选中点<strong>p</strong>的亮度(记为<strong>I<sub>p</sub></strong>)要高出或低出阈值<strong>t</strong>，则点<strong>p</strong>被归类为一个角点。该条件可以写成：</p>
<ul>
<li><p>条件一：一组<strong>N</strong>个相邻的像素点的集合记为<strong>S</strong>，$\forall x \in S$，<strong>x</strong>的亮度&gt;<strong>I<sub>p</sub></strong>+阈值<strong>t</strong>，或$I_{x} &gt; I_{p}+t$</p>
</li>
<li><p>条件二：一组<strong>N</strong>个相邻的像素点的集合记为<strong>S</strong>，$\forall x \in S$，<strong>x</strong>的亮度&lt;<strong>I<sub>p</sub></strong>-阈值<strong>t</strong>，或$I_{x} &lt; I_{p}-t$</p>
<p>在满足其中任意一个条件时，选中点<strong>p</strong>可以被归类为一个角点。在选择相邻像素点数量<strong>N</strong>与阈值<strong>t</strong>的数值上需要进行权衡。既不应该检测出过多的角点，又不应该为了达成高准确度(high performance)而牺牲计算效率。在没有机器学习的优化下，<strong>N</strong>的值一般取为12。一个高速检测方法(A high-speed test method)可以用于排除不是角点的点。</p>
<p><img src="https://i.loli.net/2020/07/24/vNZriPEDVKm8hob.jpg" alt="330px-FAST_Corner_Detector.jpg"></p>
</li>
</ul>
<h2 id="高速检测"><a href="#高速检测" class="headerlink" title="高速检测"></a>高速检测</h2><p>用于排除非角点的高速检测是通过对编号为1,9,5,13的4个对照(example)像素点进行检测来实现的。因为对于角点来说，应该至少有全都比它更亮或更暗的12个连续点，所以在这4个对照像素点中，至少应该有3个像素点全都比选中点更亮或更暗。首先对点1和点9进行检测，如果它们的亮度都处于阈值范围[<strong>I<sub>p</sub></strong>-<strong>t</strong>,<strong>I<sub>p</sub></strong>+<strong>t</strong>]内，则选中点<strong>p</strong>不是角点，否则，对点5和点13进行进一步的检测，确认是否其中三个点全都比选中点更亮或更暗。如果有三个点确实满足条件，则对剩下的全部点进行检测来确定选中点的最终类型。根据发明者在他的第一篇论文中所说<sup>[<a href="#ref">2</a>]</sup>，对于一个角点平均需要检测3.8个像素点。与每个角点8.5个像素点(指分段测试检测？)相比，3.8是能够高度改善性能的巨大降低。</p>
<p>然而，这个检测方法有着几个缺点：</p>
<ol>
<li>高速检测不能被很好地推广到<strong>N&lt;12</strong>的情况，如果<strong>N&lt;12</strong>，角点<strong>p</strong>的4个对照像素点中可能只存在两个全都比<strong>p</strong>更亮或更暗。</li>
<li>检测的效率取决于检测点的选取与顺序。但是不太可能结合角点的分布选出最优的检测点。(it is unlikely that the chosen pixels are optimal which take concerns about the distribution of corner appearances.)</li>
<li>检测到的多个特征点彼此相邻。(Multiple features are detected adjacent to one another.)</li>
</ol>
<blockquote>
<p>2020.7.20 16:20 by Jzjerry</p>
</blockquote>
<h2 id="机器学习优化"><a href="#机器学习优化" class="headerlink" title="机器学习优化"></a>机器学习优化</h2><p>为了处理高速检测的前两个缺点，人们引入了一种机器学习的方法来帮助改进这一检测算法。这种机器学习方法分为两个阶段。第一阶段，在一个训练图像集上进行给定<strong>N</strong>值的角点检测，这个训练图像集偏向于特定的目标应用领域。通过最简单的实施方法，即提取一个16像素点的圆环并取其亮度和一个适当的阈值进行比较，可检测到角点。</p>
<p>对于选中点<strong>p</strong>，圆上的每一个位置<strong>x</strong>∈{1,2,3,…,16}表示为<strong>p→x</strong>。每个像素的状态<strong>S<sub>p→x</sub></strong>必须处于下列三种状态中的一种：</p>
<ul>
<li><strong>d，I<sub>p→x</sub> ≤ I<sub>p</sub>-t</strong>（更暗）</li>
<li><strong>s，I<sub>p</sub>-t ≤ I<sub>p→x</sub> ≤ I<sub>p</sub>+t</strong>（相似）</li>
<li><strong>b，I<sub>p→x</sub> ≥ I<sub>p</sub>+t</strong>（更亮）</li>
</ul>
<p>然后选取一个点<strong>x</strong>（对所有<strong>p</strong>都取同一个）分割<strong>P</strong>（所有训练图像的所有像素点的集合）为三个不同的子集，<strong>P<sub>d</sub>,P<sub>s</sub>,P<sub>b</sub></strong>，其中：</p>
<ul>
<li><strong>P<sub>d</sub> = {p ∈ P : S<sub>p→x</sub> = d}</strong></li>
<li><strong>P<sub>s</sub> = {p ∈ P : S<sub>p→x</sub> = s}</strong></li>
<li><strong>P<sub>b</sub> = {p ∈ P : S<sub>p→x</sub> = b}</strong></li>
</ul>
<p>第二阶段，使用决策树算法，将ID3算法用于16个位置上，取得最大的信息增益。取<strong>K<sub>p</sub></strong>为一个表示<strong>p</strong>是否为角点的布尔型变量，然后用<strong>K<sub>p</sub></strong>的熵来表示(measure)<strong>p</strong>是否为角点的信息。对于一组像素<strong>Q</strong>，<strong>K<sub>p</sub></strong>的总熵（未归一化）为：</p>
<ul>
<li>$ H(Q)=(c+n)log_{2}(c+n)-clog_{2}c-nlog_{2}n$<ul>
<li>c = |{ i∈Q:K<sub>i</sub> is true}|(角点数)</li>
<li>n = |{ i∈Q:K<sub>i</sub> is false}|(非角点数)</li>
</ul>
</li>
</ul>
<p>信息增益可以被表示为：</p>
<ul>
<li>$H_{g} = H(P)-H(P_{b})-H(P_{s})-H(P_{d})$</li>
</ul>
<p>为了选出每个能够的到最大信息增益的<strong>x</strong>点，对每个子集进行一个递归过程。例如，首先选出具有最多的信息的，用于分割<strong>P</strong>为<strong>P<sub>d</sub>,P<sub>s</sub>,P<sub>b</sub></strong>的<strong>x</strong>点；然后对每个子集<strong>P<sub>d</sub>,P<sub>s</sub>,P<sub>b</sub></strong>，选出能产生最大信息增益的<strong>y</strong>点（可能和<strong>x</strong>点为同一个）。这个递归过程在熵为0的时候结束，这时子集中所有像素不是角点就是非角点。</p>
<p>生成的决策树可以转换为程序代码，例如C与C++代码，只需要一串嵌套的if-else语句就可以实现。如果想要得到最优化，可以使用按配置优化（Profile-guided Optimization）编译代码。编译后的代码可以用于对其它图像进行角点检测。</p>
<p>值得注意的是，使用决策树算法检测的角点会与分段测试检测得到的角点有微小的差异。这是因为决策树模型是基于训练数据的，并不能覆盖所有可能的角点。</p>
<h2 id="非极大值抑制"><a href="#非极大值抑制" class="headerlink" title="非极大值抑制"></a>非极大值抑制</h2><p>“由于分段检测并不能计算出角点响应函数，非极大值抑制不能直接用于产生特征。”然而，如果<strong>N</strong>是固定的，对于每一个像素点<strong>p</strong>，角点强度(corner strength)可定义为使<strong>p</strong>成为角点的阈值<strong>t</strong>的极大值。因此，有两种方法可以用于计算角点强度：</p>
<ul>
<li>二分搜索算法可以被用于找到使<strong>p</strong>点仍是一个角点的<strong>t</strong>的极大值。每次都会为决策树算法设定一个不同的<strong>t</strong>值。当算法找到了最大的<strong>t</strong>值时，就可以将该值作为角点强度。</li>
<li>另外一种方法是使用迭代法(iteration scheme)，每次使<strong>t</strong>值增加一个能使<strong>p</strong>通过角点检测的极小值。</li>
</ul>
<h2 id="FAST-ER-更强的重复性"><a href="#FAST-ER-更强的重复性" class="headerlink" title="FAST-ER:更强的重复性"></a>FAST-ER:更强的重复性</h2><p>FAST-ER检测是一种使用元启发式算法的FAST检测优化算法，其使用元启发式算法是模拟退火算法。在最优化之后，决策树的结构将会最优化，且适合于检测重复率高的点。但是模拟退火算法作为一种元启发式算法，每次会生成不同的最优决策树。因此，最好有效地进行大量的迭代，来寻找接近实际最优的方案。根据Rosten所说，在3GHz主频的Pentium4上重复100遍10万次的FAST迭代优化需要大约200个小时。</p>
<h2 id="与其他检测的对比"><a href="#与其他检测的对比" class="headerlink" title="与其他检测的对比"></a>与其他检测的对比</h2><p>在Rosten的研究中<sup>[<a href="#ref">3</a>]</sup>，他对不同数据集下的FAST和FAST-ER检测进行了评价，并与DoG，Harris，Harris-Laplace，Shi-Tomasi和SUSAN角点检测进行了比较。</p>
<p>除了FAST检测之外，其他检测的参数设置如下：</p>
<table>
<thead>
<tr>
<th align="center">检测类型</th>
<th align="center">参数设置</th>
<th align="center">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DoG</td>
<td align="center">八分尺度(Scales per octave)</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">初始模糊 σ</td>
<td align="center">0.8</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">八分组数(Octaves)</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">SUSAN</td>
<td align="center">距离阈值</td>
<td align="center">4.0</td>
</tr>
<tr>
<td align="center">Harris，Shi-Tomasi</td>
<td align="center">模糊 σ</td>
<td align="center">2.5</td>
</tr>
<tr>
<td align="center">Harris-Laplace</td>
<td align="center">初始模糊 σ</td>
<td align="center">0.8</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">Harris 模糊</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">八分组数(Octaves)</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">八分尺度(Scales per octave)</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">通用参数</td>
<td align="center">ε</td>
<td align="center">5像素</td>
</tr>
</tbody></table>
<blockquote>
<p>译者注：各参数的具体中文译名与意义有待考证</p>
</blockquote>
<ul>
<li><p>重复性测试结果以所有数据集上，每帧0-2000个角点的重复性曲线下的平均面积（多余的噪声干扰除外）表示：</p>
<table>
<thead>
<tr>
<th align="center">检测类型</th>
<th align="center">A</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FAST-ER</td>
<td align="center">1313.6</td>
</tr>
<tr>
<td align="center">FAST-9</td>
<td align="center">1304.57</td>
</tr>
<tr>
<td align="center">DOG</td>
<td align="center">1275.59</td>
</tr>
<tr>
<td align="center">Shi &amp; Tomasi</td>
<td align="center">1219.08</td>
</tr>
<tr>
<td align="center">Harris</td>
<td align="center">1195.2</td>
</tr>
<tr>
<td align="center">Harris-Laplace</td>
<td align="center">1153.13</td>
</tr>
<tr>
<td align="center">FAST-12</td>
<td align="center">1121.53</td>
</tr>
<tr>
<td align="center">SUSAN</td>
<td align="center">1116.79</td>
</tr>
<tr>
<td align="center">随机</td>
<td align="center">271.73</td>
</tr>
</tbody></table>
</li>
<li><p>速度测试在主频3.0GHz的Pentium4-D处理器上进行。数据集被分为训练集与测试集。训练集由101个分辨率为992×668像素的单色图像组成。测试集由4968帧352×288像素的单色视频组成。测试结果如下：</p>
<table>
<thead>
<tr>
<th align="center">检测类型</th>
<th align="center">训练集像素速率</th>
<th align="center">测试集像素速率</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FAST n=9</td>
<td align="center">188</td>
<td align="center">179</td>
</tr>
<tr>
<td align="center">FAST n=12</td>
<td align="center">158</td>
<td align="center">154</td>
</tr>
<tr>
<td align="center">Original FAST n=12</td>
<td align="center">79</td>
<td align="center">82.2</td>
</tr>
<tr>
<td align="center">FAST-ER</td>
<td align="center">75.4</td>
<td align="center">67.5</td>
</tr>
<tr>
<td align="center">SUSAN</td>
<td align="center">12.3</td>
<td align="center">13.6</td>
</tr>
<tr>
<td align="center">Harris</td>
<td align="center">8.05</td>
<td align="center">7.90</td>
</tr>
<tr>
<td align="center">Shi-Tomasi</td>
<td align="center">6.50</td>
<td align="center">6.50</td>
</tr>
<tr>
<td align="center">DoG</td>
<td align="center">4.72</td>
<td align="center">5.10</td>
</tr>
</tbody></table>
<blockquote>
<p>译者注：这里的原文是<strong>pixel rate</strong>，考虑到是速度测试就翻译成了速率，我认为是每秒处理的像素数。</p>
</blockquote>
<blockquote>
<p>2020.7.24 14:03 by Jzjerry 粗译完成</p>
<p>2020.8.17 18:44 by Jzjerry 修改一处名词翻译与一处数据空缺</p>
</blockquote>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><span id="ref">参考</span></h2><ol>
<li>Rosten, Edward; Drummond, Tom (2006). “Machine Learning for High-speed Corner Detection”. <em>Computer Vision – ECCV 2006</em>. Lecture Notes in Computer Science. <strong>3951</strong>. pp. 430–443. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" target="_blank" rel="noopener">doi</a>:<a href="https://doi.org/10.1007%2F11744023_34" target="_blank" rel="noopener">10.1007/11744023_34</a>. <a href="https://en.wikipedia.org/wiki/ISBN_(identifier)" target="_blank" rel="noopener">ISBN</a> <a href="https://en.wikipedia.org/wiki/Special:BookSources/978-3-540-33832-1" target="_blank" rel="noopener">978-3-540-33832-1</a>. <a href="https://en.wikipedia.org/wiki/S2CID_(identifier)" target="_blank" rel="noopener">S2CID</a> <a href="https://api.semanticscholar.org/CorpusID:1388140" target="_blank" rel="noopener">1388140</a>.</li>
<li>Edward Rosten, <a href="http://edwardrosten.com/work/rosten_2005_annotations.pdf" target="_blank" rel="noopener">Real-time Video Annotations for Augmented Reality</a></li>
<li>Edward Rosten, <a href="http://lanl.arxiv.org/pdf/0810.2434" target="_blank" rel="noopener">FASTER and better: A machine learning approach to corner detection</a></li>
</ol>
<h2 id="文献"><a href="#文献" class="headerlink" title="文献"></a>文献</h2><ul>
<li>Rosten, Edward; Tom Drummond (2005). <a href="http://edwardrosten.com/work/rosten_2005_tracking.pdf" target="_blank" rel="noopener"><em>Fusing points and lines for high performance tracking</em></a> (PDF). <em>IEEE International Conference on Computer Vision</em>. <strong>2</strong>. pp. 1508–1511. <a href="https://en.wikipedia.org/wiki/CiteSeerX_(identifier)" target="_blank" rel="noopener">CiteSeerX</a> <a href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.60.4715" target="_blank" rel="noopener">10.1.1.60.4715</a>. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" target="_blank" rel="noopener">doi</a>:<a href="https://doi.org/10.1109%2FICCV.2005.104" target="_blank" rel="noopener">10.1109/ICCV.2005.104</a>. <a href="https://en.wikipedia.org/wiki/ISBN_(identifier)" target="_blank" rel="noopener">ISBN</a> <a href="https://en.wikipedia.org/wiki/Special:BookSources/978-0-7695-2334-7" target="_blank" rel="noopener">978-0-7695-2334-7</a>.</li>
<li>Rosten, Edward; Reid Porter; Tom Drummond (2010). “FASTER and better: A machine learning approach to corner detection”. <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>. <strong>32</strong> (1): 105–119. <a href="https://en.wikipedia.org/wiki/ArXiv_(identifier)" target="_blank" rel="noopener">arXiv</a>:<a href="https://arxiv.org/abs/0810.2434" target="_blank" rel="noopener">0810.2434</a>. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" target="_blank" rel="noopener">doi</a>:<a href="https://doi.org/10.1109%2FTPAMI.2008.275" target="_blank" rel="noopener">10.1109/TPAMI.2008.275</a>. <a href="https://en.wikipedia.org/wiki/PMID_(identifier)" target="_blank" rel="noopener">PMID</a> <a href="https://pubmed.ncbi.nlm.nih.gov/19926902" target="_blank" rel="noopener">19926902</a>.</li>
<li>Rosten, Edward; Tom Drummond (2006). <a href="http://edwardrosten.com/work/rosten_2006_machine.pdf" target="_blank" rel="noopener"><em>Machine learning for high-speed corner detection</em></a> (PDF). <em>European Conference on Computer Vision</em>. Lecture Notes in Computer Science. <strong>1</strong>. pp. 430–443. <a href="https://en.wikipedia.org/wiki/CiteSeerX_(identifier)" target="_blank" rel="noopener">CiteSeerX</a> <a href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.64.8513" target="_blank" rel="noopener">10.1.1.64.8513</a>. <a href="https://en.wikipedia.org/wiki/Doi_(identifier)" target="_blank" rel="noopener">doi</a>:<a href="https://doi.org/10.1007%2F11744023_34" target="_blank" rel="noopener">10.1007/11744023_34</a>. <a href="https://en.wikipedia.org/wiki/ISBN_(identifier)" target="_blank" rel="noopener">ISBN</a> <a href="https://en.wikipedia.org/wiki/Special:BookSources/978-3-540-33832-1" target="_blank" rel="noopener">978-3-540-33832-1</a>.</li>
</ul>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="http://www.inf.ed.ac.uk/teaching/courses/av/index.html" target="_blank" rel="noopener">Advanced Vision homepage</a></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-Vision/" rel="tag">Computer Vision</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-Try-On-Robocup2D"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/16/Try-On-Robocup2D/"
    >Try RoboCup2D——开发文档</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/07/16/Try-On-Robocup2D/" class="article-date">
  <time datetime="2020-07-16T07:53:34.000Z" itemprop="datePublished">2020-07-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="CSU-ThreeNoobs-开发文档"><a href="#CSU-ThreeNoobs-开发文档" class="headerlink" title="CSU_ThreeNoobs 开发文档"></a>CSU_ThreeNoobs 开发文档</h1><p><strong><em>CSU_ThreeNoobs</em></strong> 是在 <strong><em>CSU_Yunlu2012</em></strong> Robocup 2D仿真足球队原有代码的基础上，进行了部分代码上的优化并新增了一些简单函数的2D仿真足球队程序。</p>
<blockquote>
<p>2020.07.20</p>
<p>本改进在2020年CSU校赛中取得了前50%的成绩，以一分之差错失三等奖，实在是太菜了</p>
</blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>经过一定数量的自我对局训练与比赛情况分析，我们努力观察了足球队在比赛过程中存在的缺点，并查阅了大量文献，钻研代码构造，最终对原有的代码进行了一下的改动：</p>
<ul>
<li><h4 id="体力与冲刺速度平衡策略改动"><a href="#体力与冲刺速度平衡策略改动" class="headerlink" title="体力与冲刺速度平衡策略改动"></a>体力与冲刺速度平衡策略改动</h4><p>这一改动的灵感来源于2019年Robocup冠军队伍 <strong><em>Fractals2019</em></strong> 的队伍文献：</p>
<blockquote>
<p>Gliders2d-v1.1: stamina management with higher dash power rates (less conservative usage of the available stamina balance;<code>strategy.cpp</code><a href="#refer-1"><sup>1</sup></a></p>
</blockquote>
<p>其中采取了更加激进的体力平衡策略，使得球员在获取合适的冲刺速度时更可能获得较高的冲刺速度。在<code>strategy.cpp</code>中具体改动代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*in Strategy::get_normal_dash_power( const WorldModel &amp; wm )*/</span></span><br><span class="line">    <span class="comment">/*--------------------------------------------------------*/</span></span><br><span class="line">    <span class="keyword">double</span> dash_power = ServerParam::i().maxDashPower();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> my_inc</span><br><span class="line">        = wm.self().playerType().staminaIncMax()</span><br><span class="line">        * wm.self().recovery();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( wm.self().pos().x &gt; wm.ourDefenseLineX()   <span class="comment">// 20140930  '&gt;' -&gt; '&lt;'</span></span><br><span class="line">         &amp;&amp; wm.ball().pos().x &lt; wm.ourDefenseLineX() + <span class="number">25.0</span> ) <span class="comment">//20.0 -&gt; 25.0</span></span><br><span class="line">    &#123;</span><br><span class="line">        dlog.addText( Logger::TEAM,</span><br><span class="line">                      __FILE__<span class="string">": (get_normal_dash_power) correct DF line. keep max power"</span> );</span><br><span class="line">        <span class="comment">// keep max power</span></span><br><span class="line">        dash_power = ServerParam::i().maxDashPower();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// exist kickable teammate</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( wm.existKickableTeammate()</span><br><span class="line">              &amp;&amp; ( wm.ball().distFromSelf() &lt; <span class="number">20.0</span> ) )</span><br><span class="line"><span class="comment">//                 || ( wm.self().pos().x - )</span></span><br><span class="line">    &#123;</span><br><span class="line">        dash_power = <span class="built_in">std</span>::<span class="built_in">min</span>( my_inc * <span class="number">1.1</span>,</span><br><span class="line">                               ServerParam::i().maxDashPower() );</span><br><span class="line">        <span class="keyword">if</span> ( ! s_recover_mode</span><br><span class="line">        &amp;&amp; wm.self().pos().x &lt; wm.ourDefenseLineX()</span><br><span class="line">        &amp;&amp; wm.ball().pos().x &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dash_power = <span class="built_in">std</span>::<span class="built_in">min</span>( dash_power * <span class="number">1.5</span> , ServerParam::i().maxDashPower() );</span><br><span class="line">        &#125;</span><br><span class="line">        dlog.addText( Logger::TEAM,</span><br><span class="line">                      __FILE__<span class="string">": (get_normal_dash_power) exist kickable teammate. dash_power=%.1f"</span>,</span><br><span class="line">                      dash_power );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// in offside area</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( wm.self().pos().x &gt; wm.offsideLineX() )</span><br><span class="line">    &#123;</span><br><span class="line">        dash_power = ServerParam::i().maxDashPower();</span><br><span class="line">        <span class="keyword">if</span>( s_recover_mode &amp;&amp; wm.ball().pos().absX() &lt; <span class="number">15.0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dash_power = dash_power * <span class="number">0.8</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( wm.getOpponentGoalie()-&gt;distFromSelf() &gt; <span class="number">20.0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dash_power = dash_power * <span class="number">0.9</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        dlog.addText( Logger::TEAM,</span><br><span class="line">                      __FILE__<span class="string">": in offside area. dash_power=%.1f"</span>,</span><br><span class="line">                      dash_power );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( wm.ball().pos().x &gt; <span class="number">25.0</span></span><br><span class="line">              &amp;&amp; wm.ball().pos().x &gt; wm.self().pos().x + <span class="number">10.0</span></span><br><span class="line">              &amp;&amp; self_min &lt; opp_min - <span class="number">6</span></span><br><span class="line">              &amp;&amp; mate_min &lt; opp_min - <span class="number">6</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        dash_power = bound( ServerParam::i().maxDashPower() * <span class="number">0.1</span>,</span><br><span class="line">                            my_inc * <span class="number">0.5</span>,</span><br><span class="line">                            ServerParam::i().maxDashPower() );</span><br><span class="line">        dlog.addText( Logger::TEAM,</span><br><span class="line">                      __FILE__<span class="string">": (get_normal_dash_power) opponent ball dash_power=%.1f"</span>,</span><br><span class="line">                      dash_power );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( s_recover_mode )</span><br><span class="line">    &#123;</span><br><span class="line">        dash_power = my_inc - <span class="number">25.0</span>; <span class="comment">// preffered recover value</span></span><br><span class="line">        <span class="keyword">if</span> ( dash_power &lt; <span class="number">0.0</span> ) dash_power = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        dlog.addText( Logger::TEAM,</span><br><span class="line">                      __FILE__<span class="string">": (get_normal_dash_power) recovering"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// normal</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        dash_power = <span class="built_in">std</span>::<span class="built_in">min</span>( my_inc * <span class="number">1.7</span>,</span><br><span class="line">                               ServerParam::i().maxDashPower() );</span><br><span class="line">        dlog.addText( Logger::TEAM,</span><br><span class="line">                      __FILE__<span class="string">": (get_normal_dash_power) normal mode dash_power=%.1f"</span>,</span><br><span class="line">                      dash_power );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dash_power;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在原有代码中，<code>if( s_recover_mode )</code>这一判断语句位于决策层的较高位置，将体力的恢复放在了比较高的优先级。我们尝试将该决策放在了靠后的位置，让球员更加优先考虑场上情况来尽力使用体力，防止部分球员的体力被浪费。我们还在决策层中加入了中场情况与进攻区情况的体力决策，并在决策中具体再根据体力恢复模式进行差异化的冲刺速度决定。</p>
</li>
<li><h4 id="铲球动作的分情况决策"><a href="#铲球动作的分情况决策" class="headerlink" title="铲球动作的分情况决策"></a>铲球动作的分情况决策</h4><p>我们经过观察和总结，决定在<code>bhv_BasicMove.cpp</code>中的铲球动作按照情况进行更加细化的决策处理，具体代码改变如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in Bhv_BasicMove::execute( PlayerAgent * agent )*/</span></span><br><span class="line">    <span class="comment">//-----------------------------------------------</span></span><br><span class="line">    <span class="comment">// tackle</span></span><br><span class="line">    <span class="keyword">double</span> min_tackle_prob = <span class="number">0.8</span>;</span><br><span class="line">    <span class="keyword">double</span> tackle_angle = <span class="number">80.0</span>;</span><br><span class="line">    <span class="keyword">const</span> WorldModel &amp; wm = agent-&gt;world();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( Bhv_SetPlay::is_delaying_tactics_situation(agent) )</span><br><span class="line">    &#123;</span><br><span class="line">        min_tackle_prob = <span class="number">0.6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( wm.ball().pos().x &lt; <span class="number">-22.0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( FieldAnalyzer::is_ball_moving_to_our_goal( wm.ball().pos() , wm.ball().vel() , <span class="number">0</span> ))</span><br><span class="line">        &#123;</span><br><span class="line">            min_tackle_prob = <span class="number">0.7</span>;</span><br><span class="line">            <span class="keyword">if</span> ( wm.self().pos().x &lt; wm.ball().pos().x )</span><br><span class="line">            &#123;</span><br><span class="line">                tackle_angle = <span class="number">20.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            min_tackle_prob = <span class="number">0.9</span>;</span><br><span class="line">            <span class="keyword">if</span> ( wm.self().pos().x &lt; wm.ball().pos().x )</span><br><span class="line">            &#123;</span><br><span class="line">                tackle_angle = <span class="number">20.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( wm.ball().pos().x &gt; <span class="number">22.0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        min_tackle_prob = <span class="number">0.6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// tackle end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( Bhv_BasicTackle( min_tackle_prob, tackle_angle ).execute( agent ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG2014</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; agent-&gt;world().time() &lt;&lt; __FILE__ &lt;&lt; agent-&gt;world().self().unum() &lt;&lt; __FILE__ &lt;&lt; <span class="string">": basic_tackle...\n"</span>;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DEBUG2014</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在原代码中，对于<code>BasicMove.excute()</code>中最上层的铲球动作实现比较死板，是固定的以最小成功率80%，角度80.0作为铲球参数。在此基础上，我们根据拖延战术情况、球的位置情况、对方进攻情况分别采取不同的铲球策略。在<code>bhv_dangerAreaTackle.h</code>中，我们也调整了危险区域内铲球的默认最小成功率。</p>
</li>
<li><h4 id="紧急射门函数"><a href="#紧急射门函数" class="headerlink" title="紧急射门函数"></a>紧急射门函数</h4><p>在自我对局的过程中，我们发现出现了比赛时间即将结束时射门过于犹豫，最终时间用尽的情况。为此我们尝试新建了两个函数来解决时间不足时的射门问题。在<code>chain_action/shoot_generator.cpp</code>中新增具体代码如下：</p>
<p>剩余时间判断函数<code>Time_Remain_Check()</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line"> Time_Remain_Check(<span class="keyword">const</span> WorldModel &amp;wm)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> GameTime <span class="title">s_update_time</span><span class="params">( <span class="number">0</span>, <span class="number">0</span> )</span></span>;</span><br><span class="line"></span><br><span class="line">    s_update_time = wm.time();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ServerParam &amp; SP = ServerParam::i();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( s_update_time.cycle() &lt; ( SP.halfTime() * <span class="number">10</span> - <span class="number">100</span> ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( s_update_time.cycle() &lt; SP.halfTime()*<span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( s_update_time.cycle() &lt; ( SP.nrNormalHalfs() * SP.halfTime() * <span class="number">10</span> - <span class="number">100</span> ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( s_update_time.cycle() &lt; SP.nrNormalHalfs() * SP.halfTime() * <span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>该函数用于检测比赛时间是否处于最后10秒。</p>
<p>紧急射门函数<code>generateEmgerancyShoot()</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line">ShootGenerator::generateEmgerancyShoot(<span class="keyword">const</span> WorldModel &amp; wm)</span><br><span class="line">&#123;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> GameTime <span class="title">s_update_time</span><span class="params">( <span class="number">0</span>, <span class="number">0</span> )</span></span>;</span><br><span class="line">    s_update_time = wm.time();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ServerParam &amp; SP = ServerParam::i();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( Time_Remain_Check( wm ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( wm.self().pos().dist2( SP.theirTeamGoalPos() ) &gt; <span class="built_in">std</span>::<span class="built_in">pow</span>( <span class="number">40.0</span>, <span class="number">2</span> ) ) <span class="comment">//30.0 -&gt; 40.0</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG_PRINT</span></span><br><span class="line">        dlog.addText( Logger::SHOOT,</span><br><span class="line">                      __FILE__<span class="string">": over shootable distance"</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    M_first_ball_pos = ( wm.self().isKickable()</span><br><span class="line">                         ? wm.ball().pos()</span><br><span class="line">                         : wm.ball().pos() + wm.ball().vel() );</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG_PROFILE</span></span><br><span class="line">    MSecTimer timer;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function">Vector2D <span class="title">goal_l</span><span class="params">( SP.pitchHalfLength(), -SP.goalHalfWidth() )</span></span>;</span><br><span class="line">    <span class="function">Vector2D <span class="title">goal_r</span><span class="params">( SP.pitchHalfLength(), +SP.goalHalfWidth() )</span></span>;</span><br><span class="line"></span><br><span class="line">    goal_l.y += <span class="built_in">std</span>::<span class="built_in">min</span>( <span class="number">1.5</span>,</span><br><span class="line">                          <span class="number">0.6</span> + goal_l.dist( M_first_ball_pos ) * <span class="number">0.042</span> );</span><br><span class="line">    goal_r.y -= <span class="built_in">std</span>::<span class="built_in">min</span>( <span class="number">1.5</span>,</span><br><span class="line">                          <span class="number">0.6</span> + goal_r.dist( M_first_ball_pos ) * <span class="number">0.042</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( wm.self().pos().x &gt; SP.pitchHalfLength() - <span class="number">1.0</span></span><br><span class="line">         &amp;&amp; wm.self().pos().absY() &lt; SP.goalHalfWidth() )</span><br><span class="line">    &#123;</span><br><span class="line">        goal_l.x = wm.self().pos().x + <span class="number">1.5</span>;</span><br><span class="line">        goal_r.x = wm.self().pos().x + <span class="number">1.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> DIST_DIVS = <span class="number">13</span>; <span class="comment">// 25 -&gt; 13</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> dist_step = <span class="built_in">std</span>::<span class="built_in">fabs</span>( goal_l.y - goal_r.y ) / ( DIST_DIVS - <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG_PRINT</span></span><br><span class="line">    dlog.addText( Logger::SHOOT,</span><br><span class="line">                  __FILE__<span class="string">": ===== Shoot search range=(%.1f %.1f)-(%.1f %.1f) dist_step=%.1f ====="</span>,</span><br><span class="line">                  goal_l.x, goal_l.y, goal_r.x, goal_r.y, dist_step );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; DIST_DIVS; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        ++M_total_count;</span><br><span class="line"></span><br><span class="line">        Vector2D target_point = goal_l;</span><br><span class="line">        target_point.y += dist_step * i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG_PRINT</span></span><br><span class="line">        dlog.addText( Logger::SHOOT,</span><br><span class="line">                      <span class="string">"%d: ===== shoot target(%.2f %.2f) ===== "</span>,</span><br><span class="line">                      M_total_count,</span><br><span class="line">                      target_point.x, target_point.y );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        createShoot( wm, target_point );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    evaluateCourses( wm );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG_PROFILE</span></span><br><span class="line">    dlog.addText( Logger::SHOOT,</span><br><span class="line">                  __FILE__<span class="string">": PROFILE %d/%d. elapsed=%.3f [ms]"</span>,</span><br><span class="line">                  (<span class="keyword">int</span>)M_courses.<span class="built_in">size</span>(),</span><br><span class="line">                  DIST_DIVS,</span><br><span class="line">                  timer.elapsedReal() );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的内容与原本的射门产生函数<code>generate()</code>基本相同，但是在其基础上，我们只对射门点进行了12点分，并在评价体系中对于时间不足情况下<code>kick_step_==1</code>的射门提高了评价分值，以期望得到更果断的最后射门尝试。</p>
</li>
<li><h4 id="守门员阵型文件改动"><a href="#守门员阵型文件改动" class="headerlink" title="守门员阵型文件改动"></a>守门员阵型文件改动</h4><p>在比赛观察中，我们发现被进球时的情况有很大一部分来源于守门员站位的问题。我们针对该问题，对守门员与其他球员在对方边角球的情况下的站位进行了微调。</p>
</li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><div id = "refer-1"></div>

<ul>
<li>[1] <a href="http://archive.robocup.info/Soccer/Simulation/2D/TDPs/RoboCup/2019/Fractals_SS2D_RC2019_TDP.pdf" target="_blank" rel="noopener">Fractals2019: Guiding Self-Organisation of Intelligent Agents</a></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RoboCup/" rel="tag">RoboCup</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-hello-world"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/06/hello-world/"
    >Hello World</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/07/06/hello-world/" class="article-date">
  <time datetime="2020-07-06T04:41:50.770Z" itemprop="datePublished">2020-07-06</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
</article>

    
  </article>
  

  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2022
        <i class="ri-heart-fill heart_icon"></i> Jzjerry Jiang
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/key-side.svg" alt="Through the Gate of Silver Key"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About Me</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="86"
        src="//music.163.com/outchain/player?type=2&id=476863&auto=0&height=66"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>